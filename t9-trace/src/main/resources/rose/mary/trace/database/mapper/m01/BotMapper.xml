<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="rose.mary.trace.database.mapper.m01.BotMapper">
  	<!--
  	<cache/>
  	-->
    <!-- for maria
    a.STATUS 		   	= decode(a.STATUS, '00', a.STATUS, '99', a.STATUS, #{state.status,jdbcType=VARCHAR})
      |
      V
    a.STATUS = case a.STATUS  when '00' then  a.STATUS  when '99' then  a.STATUS  else  #{state.status,jdbcType=VARCHAR} end			
     -->
	<update id="restore" parameterType="rose.mary.trace.data.common.Bot">
		<![CDATA[
		merge into TOP0503 a
		using DUAL
		   on (
			a.INTEGRATION_ID= #{state.integrationId,		jdbcType=VARCHAR} and
		    a.TRACKING_DATE = #{state.trackingDate,	 		jdbcType=VARCHAR} and		
		    a.ORG_HOST_ID   = #{state.orgHostId,			jdbcType=VARCHAR}		  		   
		   )
		when matched then
	  update set 
			 a.STATUS 			= case a.STATUS  when '00' then  a.STATUS  when '99' then  a.STATUS  else  #{state.status,jdbcType=VARCHAR} end			
			,a.RECORD_CNT		= #{state.recordCount,		jdbcType=NUMERIC}
			,a.DATA_AMT 		= #{state.dataAmount,	 	jdbcType=NUMERIC}
			,a.CMP				= #{state.compress,			jdbcType=VARCHAR}
			,a.CST 				= #{state.cost,	 			jdbcType=NUMERIC}
			,a.TDC 				= #{state.todoNodeCount,	jdbcType=NUMERIC}
			,a.FNC 				= #{state.finishNodeCount,	jdbcType=NUMERIC}
			,a.ERC			   	= #{state.errorNodeCount, 	jdbcType=NUMERIC}
			,a.ERROR_CD		   	= #{state.errorCode,	  	jdbcType=VARCHAR}
			,a.ERROR_MSG		= #{state.errorMessage,	  	jdbcType=VARCHAR}			
			,a.MOD_DATE	  		= #{modDate,		 	  	jdbcType=VARCHAR}	 	  
		when not matched then 
	  insert (             
			 a.INTEGRATION_ID 		
			,a.TRACKING_DATE 		
			,a.ORG_HOST_ID 		
			,a.STATUS 	
			,a.MATCH		
			,a.RECORD_CNT			
			,a.DATA_AMT 			
			,a.CMP				
			,a.CST 				
			,a.TDC 				
			,a.FNC 				
			,a.ERC				
			,a.ERROR_CD			
			,a.ERROR_MSG
			,a.BUSINESS_ID
			,a.BUSINESS_NM 		
			,a.INTERFACE_NM     
			,a.INTERFACE_ID   
			,a.CHANNEL_ID       
			,a.CHANNEL_NM       
			,a.DATA_PR_DIR      
			,a.DATA_PR_DIR_NM  
			,a.DATA_PR_METHOD   
			,a.DATA_PR_METHOD_NM
			,a.APP_PR_METHOD    
			,a.APP_PR_METHOD_NM 
			,a.SND_SYSTEM_ID    
			,a.SND_SYSTEM_NM    
			,a.SND_RES_TYPE     
			,a.SND_RES_NM 
			,a.SND_ORG_ID
			,a.SND_ORG_NM
			,a.RCV_SYSTEM_ID    
			,a.RCV_SYSTEM_NM    
			,a.RCV_RES_TYPE     
			,a.RCV_RES_NM
			,a.RCV_ORG_ID
			,a.RCV_ORG_NM           			
			,a.REG_DATE                    
		) values (                            
			 #{state.integrationId,			jdbcType=VARCHAR}
			,#{state.trackingDate,	 		jdbcType=VARCHAR}
			,#{state.orgHostId,				jdbcType=VARCHAR}
			,#{state.status,		 		jdbcType=VARCHAR}
			,#{state.match,					jdbcType=VARCHAR}
			,#{state.recordCount,			jdbcType=NUMERIC}
			,#{state.dataAmount,	 		jdbcType=NUMERIC}
			,#{state.compress,				jdbcType=VARCHAR}
			,#{state.cost,	 				jdbcType=NUMERIC}
			,#{state.todoNodeCount,	 		jdbcType=NUMERIC}
			,#{state.finishNodeCount,	 	jdbcType=NUMERIC}
			,#{state.errorNodeCount,	 	jdbcType=NUMERIC}
			,#{state.errorCode,	 			jdbcType=VARCHAR}
			,#{state.errorMessage,			jdbcType=VARCHAR}
			,#{interfaceInfo.businessId,	jdbcType=VARCHAR}
			,#{interfaceInfo.businessNm,	jdbcType=VARCHAR}
			,#{interfaceInfo.interfaceNm,	jdbcType=VARCHAR}
			,#{interfaceInfo.interfaceId,	jdbcType=VARCHAR}
			,#{interfaceInfo.channelId,		jdbcType=VARCHAR}
			,#{interfaceInfo.channelNm,		jdbcType=VARCHAR}
			,#{interfaceInfo.dataPrDir,		jdbcType=VARCHAR}
			,#{interfaceInfo.dataPrDirNm,	jdbcType=VARCHAR}
			,#{interfaceInfo.dataPrMethod,	jdbcType=VARCHAR}
			,#{interfaceInfo.dataPrMethodNm,jdbcType=VARCHAR}
			,#{interfaceInfo.appPrMethod,	jdbcType=VARCHAR}
			,#{interfaceInfo.appPrMethodNm, jdbcType=VARCHAR}
			,#{interfaceInfo.sendSystemId,	jdbcType=VARCHAR}
			,#{interfaceInfo.sendSystemNm,	jdbcType=VARCHAR}
			,#{interfaceInfo.sendResource,	jdbcType=VARCHAR}
			,#{interfaceInfo.sendResourceNm,jdbcType=VARCHAR}
			,#{interfaceInfo.sendOrgId,		jdbcType=VARCHAR}
			,#{interfaceInfo.sendOrgNm,		jdbcType=VARCHAR}
			,#{interfaceInfo.recvSystemId,	jdbcType=VARCHAR}
			,#{interfaceInfo.recvSystemNm,	jdbcType=VARCHAR}
			,#{interfaceInfo.recvResource,	jdbcType=VARCHAR}
			,#{interfaceInfo.recvResourceNm,jdbcType=VARCHAR}
			,#{interfaceInfo.recvOrgId,		jdbcType=VARCHAR}
			,#{interfaceInfo.recvOrgNm,		jdbcType=VARCHAR}
			,#{regDate,		 				jdbcType=VARCHAR}			
			
		) 
		
		]]>
	</update>
	
	
	
	<update id="updateUnmatch" parameterType="rose.mary.trace.data.common.Unmatch">
		<![CDATA[
		merge into TOP0504 a
		using DUAL
		   on (
			a.INTEGRATION_ID= #{integrationId, jdbcType=VARCHAR}		  		   
		   )
		when matched then
	  update set 
			 a.MOD_DATE	= #{modDate, jdbcType=VARCHAR}	 	  
		when not matched then 
	  insert (             
			 a.INTEGRATION_ID 					
			,a.MATCH           			
			,a.REG_DATE                    
		) values (                            
			 #{integrationId, jdbcType=VARCHAR}
			,#{match,	  	  jdbcType=VARCHAR}
			,#{regDate,		  jdbcType=VARCHAR}			
			
		) 
		
		]]>
	</update>
	
	
</mapper>