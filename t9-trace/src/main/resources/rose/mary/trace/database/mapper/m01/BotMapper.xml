<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="rose.mary.trace.database.mapper.m01.BotMapper">
  	<!--
  	<cache/>
  	-->
	<update id="restore" parameterType="rose.mary.trace.data.common.Bot">
		<choose>
			<when test="_databaseId == 'postgresql'">
				<![CDATA[
				with UPDATE_TABLE as (
					update TOP0503 
					set 
						STATUS 	= case a.STATUS  when '00' then  a.STATUS  when '99' then  a.STATUS  else  #{state.status,jdbcType=VARCHAR} end			
						,RECORD_CNT	= #{state.recordCount,		jdbcType=NUMERIC}
						,DATA_AMT 	= #{state.dataAmount,	 	jdbcType=NUMERIC}
						,CMP		= #{state.compress,			jdbcType=VARCHAR}
						,CST 		= #{state.cost,	 			jdbcType=NUMERIC}
						,TDC 		= #{state.todoNodeCount,	jdbcType=NUMERIC}
						,FNC 		= #{state.finishNodeCount,	jdbcType=NUMERIC}
						,ERC		= #{state.errorNodeCount, 	jdbcType=NUMERIC}
						,ERROR_CD	= #{state.errorCode,	  	jdbcType=VARCHAR}
						,ERROR_MSG	= #{state.errorMessage,	  	jdbcType=VARCHAR}			
						,MOD_DATE	= #{modDate,		 	  	jdbcType=VARCHAR}	 	
					where 
						INTEGRATION_ID= #{state.integrationId,		jdbcType=VARCHAR} and
						TRACKING_DATE = #{state.trackingDate,	 	jdbcType=VARCHAR} and		
						ORG_HOST_ID   = #{state.orgHostId,			jdbcType=VARCHAR}	
					returning *
				)
				insert into TOP0503 (
					INTEGRATION_ID 		
					,TRACKING_DATE 		
					,ORG_HOST_ID 		
					,STATUS 	
					,MATCH		
					,RECORD_CNT			
					,DATA_AMT 			
					,CMP				
					,CST 				
					,TDC 				
					,FNC 				
					,ERC				
					,ERROR_CD			
					,ERROR_MSG
					,BUSINESS_ID
					,BUSINESS_NM 		
					,INTERFACE_NM     
					,INTERFACE_ID   
					,CHANNEL_ID       
					,CHANNEL_NM       
					,DATA_PR_DIR      
					,DATA_PR_DIR_NM  
					,DATA_PR_METHOD   
					,DATA_PR_METHOD_NM
					,APP_PR_METHOD    
					,APP_PR_METHOD_NM 
					,SND_SYSTEM_ID    
					,SND_SYSTEM_NM    
					,SND_RES_TYPE     
					,SND_RES_NM 
					,SND_ORG_ID
					,SND_ORG_NM
					,RCV_SYSTEM_ID    
					,RCV_SYSTEM_NM    
					,RCV_RES_TYPE     
					,RCV_RES_NM
					,RCV_ORG_ID
					,RCV_ORG_NM           			
					,REG_DATE     			
				)
				select 
					#{state.integrationId,			jdbcType=VARCHAR}
					,#{state.trackingDate,	 		jdbcType=VARCHAR}
					,#{state.orgHostId,				jdbcType=VARCHAR}
					,#{state.status,		 		jdbcType=VARCHAR}
					,#{state.match,					jdbcType=VARCHAR}
					,#{state.recordCount,			jdbcType=NUMERIC}
					,#{state.dataAmount,	 		jdbcType=NUMERIC}
					,#{state.compress,				jdbcType=VARCHAR}
					,#{state.cost,	 				jdbcType=NUMERIC}
					,#{state.todoNodeCount,	 		jdbcType=NUMERIC}
					,#{state.finishNodeCount,	 	jdbcType=NUMERIC}
					,#{state.errorNodeCount,	 	jdbcType=NUMERIC}
					,#{state.errorCode,	 			jdbcType=VARCHAR}
					,#{state.errorMessage,			jdbcType=VARCHAR}
					,#{interfaceInfo.businessId,	jdbcType=VARCHAR}
					,#{interfaceInfo.businessNm,	jdbcType=VARCHAR}
					,#{interfaceInfo.interfaceNm,	jdbcType=VARCHAR}
					,#{interfaceInfo.interfaceId,	jdbcType=VARCHAR}
					,#{interfaceInfo.channelId,		jdbcType=VARCHAR}
					,#{interfaceInfo.channelNm,		jdbcType=VARCHAR}
					,#{interfaceInfo.dataPrDir,		jdbcType=VARCHAR}
					,#{interfaceInfo.dataPrDirNm,	jdbcType=VARCHAR}
					,#{interfaceInfo.dataPrMethod,	jdbcType=VARCHAR}
					,#{interfaceInfo.dataPrMethodNm,jdbcType=VARCHAR}
					,#{interfaceInfo.appPrMethod,	jdbcType=VARCHAR}
					,#{interfaceInfo.appPrMethodNm, jdbcType=VARCHAR}
					,#{interfaceInfo.sendSystemId,	jdbcType=VARCHAR}
					,#{interfaceInfo.sendSystemNm,	jdbcType=VARCHAR}
					,#{interfaceInfo.sendResource,	jdbcType=VARCHAR}
					,#{interfaceInfo.sendResourceNm,jdbcType=VARCHAR}
					,#{interfaceInfo.sendOrgId,		jdbcType=VARCHAR}
					,#{interfaceInfo.sendOrgNm,		jdbcType=VARCHAR}
					,#{interfaceInfo.recvSystemId,	jdbcType=VARCHAR}
					,#{interfaceInfo.recvSystemNm,	jdbcType=VARCHAR}
					,#{interfaceInfo.recvResource,	jdbcType=VARCHAR}
					,#{interfaceInfo.recvResourceNm,jdbcType=VARCHAR}
					,#{interfaceInfo.recvOrgId,		jdbcType=VARCHAR}
					,#{interfaceInfo.recvOrgNm,		jdbcType=VARCHAR}
					,#{regDate,		 				jdbcType=VARCHAR}	
				where not exists (select * from UPDATE_TABLE)
				]]>
			</when>
			<otherwise>
				<![CDATA[
				merge into TOP0503 a
				using DUAL
				on (
					a.INTEGRATION_ID= #{state.integrationId,		jdbcType=VARCHAR} and
					a.TRACKING_DATE = #{state.trackingDate,	 		jdbcType=VARCHAR} and		
					a.ORG_HOST_ID   = #{state.orgHostId,			jdbcType=VARCHAR}		  		   
				)
				when matched then
			update set 
					a.STATUS 			= case a.STATUS  when '00' then  a.STATUS  when '99' then  a.STATUS  else  #{state.status,jdbcType=VARCHAR} end			
					,a.RECORD_CNT		= #{state.recordCount,		jdbcType=NUMERIC}
					,a.DATA_AMT 		= #{state.dataAmount,	 	jdbcType=NUMERIC}
					,a.CMP				= #{state.compress,			jdbcType=VARCHAR}
					,a.CST 				= #{state.cost,	 			jdbcType=NUMERIC}
					,a.TDC 				= #{state.todoNodeCount,	jdbcType=NUMERIC}
					,a.FNC 				= #{state.finishNodeCount,	jdbcType=NUMERIC}
					,a.ERC			   	= #{state.errorNodeCount, 	jdbcType=NUMERIC}
					,a.ERROR_CD		   	= #{state.errorCode,	  	jdbcType=VARCHAR}
					,a.ERROR_MSG		= #{state.errorMessage,	  	jdbcType=VARCHAR}			
					,a.MOD_DATE	  		= #{modDate,		 	  	jdbcType=VARCHAR}	 	  
				when not matched then 
			insert (             
					a.INTEGRATION_ID 		
					,a.TRACKING_DATE 		
					,a.ORG_HOST_ID 		
					,a.STATUS 	
					,a.MATCH		
					,a.RECORD_CNT			
					,a.DATA_AMT 			
					,a.CMP				
					,a.CST 				
					,a.TDC 				
					,a.FNC 				
					,a.ERC				
					,a.ERROR_CD			
					,a.ERROR_MSG
					,a.BUSINESS_ID
					,a.BUSINESS_NM 		
					,a.INTERFACE_NM     
					,a.INTERFACE_ID   
					,a.CHANNEL_ID       
					,a.CHANNEL_NM       
					,a.DATA_PR_DIR      
					,a.DATA_PR_DIR_NM  
					,a.DATA_PR_METHOD   
					,a.DATA_PR_METHOD_NM
					,a.APP_PR_METHOD    
					,a.APP_PR_METHOD_NM 
					,a.SND_SYSTEM_ID    
					,a.SND_SYSTEM_NM    
					,a.SND_RES_TYPE     
					,a.SND_RES_NM 
					,a.SND_ORG_ID
					,a.SND_ORG_NM
					,a.RCV_SYSTEM_ID    
					,a.RCV_SYSTEM_NM    
					,a.RCV_RES_TYPE     
					,a.RCV_RES_NM
					,a.RCV_ORG_ID
					,a.RCV_ORG_NM           			
					,a.REG_DATE                    
				) values (                            
					#{state.integrationId,			jdbcType=VARCHAR}
					,#{state.trackingDate,	 		jdbcType=VARCHAR}
					,#{state.orgHostId,				jdbcType=VARCHAR}
					,#{state.status,		 		jdbcType=VARCHAR}
					,#{state.match,					jdbcType=VARCHAR}
					,#{state.recordCount,			jdbcType=NUMERIC}
					,#{state.dataAmount,	 		jdbcType=NUMERIC}
					,#{state.compress,				jdbcType=VARCHAR}
					,#{state.cost,	 				jdbcType=NUMERIC}
					,#{state.todoNodeCount,	 		jdbcType=NUMERIC}
					,#{state.finishNodeCount,	 	jdbcType=NUMERIC}
					,#{state.errorNodeCount,	 	jdbcType=NUMERIC}
					,#{state.errorCode,	 			jdbcType=VARCHAR}
					,#{state.errorMessage,			jdbcType=VARCHAR}
					,#{interfaceInfo.businessId,	jdbcType=VARCHAR}
					,#{interfaceInfo.businessNm,	jdbcType=VARCHAR}
					,#{interfaceInfo.interfaceNm,	jdbcType=VARCHAR}
					,#{interfaceInfo.interfaceId,	jdbcType=VARCHAR}
					,#{interfaceInfo.channelId,		jdbcType=VARCHAR}
					,#{interfaceInfo.channelNm,		jdbcType=VARCHAR}
					,#{interfaceInfo.dataPrDir,		jdbcType=VARCHAR}
					,#{interfaceInfo.dataPrDirNm,	jdbcType=VARCHAR}
					,#{interfaceInfo.dataPrMethod,	jdbcType=VARCHAR}
					,#{interfaceInfo.dataPrMethodNm,jdbcType=VARCHAR}
					,#{interfaceInfo.appPrMethod,	jdbcType=VARCHAR}
					,#{interfaceInfo.appPrMethodNm, jdbcType=VARCHAR}
					,#{interfaceInfo.sendSystemId,	jdbcType=VARCHAR}
					,#{interfaceInfo.sendSystemNm,	jdbcType=VARCHAR}
					,#{interfaceInfo.sendResource,	jdbcType=VARCHAR}
					,#{interfaceInfo.sendResourceNm,jdbcType=VARCHAR}
					,#{interfaceInfo.sendOrgId,		jdbcType=VARCHAR}
					,#{interfaceInfo.sendOrgNm,		jdbcType=VARCHAR}
					,#{interfaceInfo.recvSystemId,	jdbcType=VARCHAR}
					,#{interfaceInfo.recvSystemNm,	jdbcType=VARCHAR}
					,#{interfaceInfo.recvResource,	jdbcType=VARCHAR}
					,#{interfaceInfo.recvResourceNm,jdbcType=VARCHAR}
					,#{interfaceInfo.recvOrgId,		jdbcType=VARCHAR}
					,#{interfaceInfo.recvOrgNm,		jdbcType=VARCHAR}
					,#{regDate,		 				jdbcType=VARCHAR}			
				) 
				]]>
			</otherwise>
		</choose>

	</update>
	
	
	 
	<!-- 
		PostgreSQL for merge sentence
	-->
	<update id="updateUnmatch" parameterType="rose.mary.trace.data.common.Unmatch">
		<choose>
			<when test="_databaseId == 'postgresql'">
				<![CDATA[
				with UPDATE_TABLE as (
					update TOP0504
					set MOD_DATE	= #{modDate, jdbcType=VARCHAR}
						,MATCH    = #{match,	 jdbcType=VARCHAR}
					where INTEGRATION_ID= #{integrationId, jdbcType=VARCHAR}
					returning *
				)
				insert into TOP0504 (
					INTEGRATION_ID
					,MATCH
					,REG_DATE
				) 
				select 
					#{integrationId, jdbcType=VARCHAR}
					,#{match,	  	  jdbcType=VARCHAR}
					,#{regDate,		  jdbcType=VARCHAR}	
				where not exists (select * from UPDATE_TABLE)
				]]>
			</when>
			<otherwise>
				<![CDATA[
				merge into TOP0504 a
				using DUAL
				on (
					a.INTEGRATION_ID= #{integrationId, jdbcType=VARCHAR}		  		   
				)
				when matched then
				update set 
						a.MOD_DATE	= #{modDate, jdbcType=VARCHAR}	 	  
						,a.MATCH    = #{match,	 jdbcType=VARCHAR}
					when not matched then 
				insert (             
						a.INTEGRATION_ID 					
						,a.MATCH           			
						,a.REG_DATE                    
					) values (                            
						#{integrationId, jdbcType=VARCHAR}
						,#{match,	  	  jdbcType=VARCHAR}
						,#{regDate,		  jdbcType=VARCHAR}			
						
					) 				
				]]>
			</otherwise>
		</choose>
	</update>
	 
</mapper>